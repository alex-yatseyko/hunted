{"ast":null,"code":"var _s2 = $RefreshSig$();\n\nimport _regeneratorRuntime from \"/Users/Shared/Relocated Items/Security/Work/Web/NextTest/next-test/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/Shared/Relocated Items/Security/Work/Web/NextTest/next-test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nimport { useState, useCallback } from 'react';\nexport var useHttp = function useHttp() {\n  _s2();\n\n  _s();\n\n  var _useState = useState(false),\n      loading = _useState[0],\n      setLoading = _useState[1];\n\n  var _useState2 = useState(null),\n      error = _useState2[0],\n      setError = _useState2[1];\n\n  var request = useCallback( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n      var method,\n          body,\n          headers,\n          response,\n          data,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              method = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'GET';\n              body = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;\n              headers = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n              setLoading(true);\n              _context.prev = 4;\n              _context.next = 7;\n              return fetch(url, {\n                method: method,\n                body: body,\n                headers: headers\n              });\n\n            case 7:\n              response = _context.sent;\n              _context.next = 10;\n              return response.json();\n\n            case 10:\n              data = _context.sent;\n\n              if (response.ok) {\n                _context.next = 13;\n                break;\n              }\n\n              throw new Error('Something went wrong');\n\n            case 13:\n              setLoading(false);\n              return _context.abrupt(\"return\", data);\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](4);\n              setLoading(false);\n              setError(_context.t0);\n              throw _context.t0;\n\n            case 22:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[4, 17]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), []);\n  return {\n    loading: loading,\n    request: request,\n    error: error\n  };\n};\n\n_s2(useHttp, \"T7YJsBhH3r+NhyBD7FbG+uizrGM=\");\n\n_s(useHttp, \"MstwQpYZpw83DP6eQvw4fjC0Jxg=\");\n\n;\n\nvar _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n// to extract CSS. For backwards compatibility, we need to check we're in a\n// browser context before continuing.\n\n\nif (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n'$RefreshHelpers$' in self) {\n  var currentExports = module.__proto__.exports;\n  var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n  // templating and execution.\n\n  self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n  // it is a Refresh Boundary.\n\n  if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n    // Save the previous exports on update so we can compare the boundary\n    // signatures.\n    module.hot.dispose(function (data) {\n      data.prevExports = currentExports;\n    }); // Unconditionally accept an update to this module, we'll check if it's\n    // still a Refresh Boundary later.\n\n    module.hot.accept(); // This field is set when the previous version of this module was a\n    // Refresh Boundary, letting us know we need to check for invalidation or\n    // enqueue an update.\n\n    if (prevExports !== null) {\n      // A boundary can become ineligible if its exports are incompatible\n      // with the previous exports.\n      //\n      // For example, if you add/remove/change exports, we'll want to\n      // re-execute the importing modules, and force those components to\n      // re-render. Similarly, if you convert a class component to a\n      // function, we want to invalidate the boundary.\n      if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n        module.hot.invalidate();\n      } else {\n        self.$RefreshHelpers$.scheduleUpdate();\n      }\n    }\n  } else {\n    // Since we just executed the code for the module, it's possible that the\n    // new exports made it ineligible for being a boundary.\n    // We only care about the case when we were _previously_ a boundary,\n    // because we already accepted this update (accidental side effect).\n    var isNoLongerABoundary = prevExports !== null;\n\n    if (isNoLongerABoundary) {\n      module.hot.invalidate();\n    }\n  }\n}","map":{"version":3,"sources":["/Users/Shared/Relocated Items/Security/Work/Web/NextTest/next-test/hooks/http.hook.ts"],"names":["useHttp","loading","setLoading","useState","error","setError","request","useCallback","method","body","headers","response","fetch","data"],"mappings":"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","sourcesContent":["import { useState, useCallback } from 'react';\n\nexport const useHttp = () => {\n    const [loading, setLoading] = useState<boolean>(false)\n    const [error, setError] = useState<null | string>(null)\n\n    const request = useCallback(async (url: string, method: string = 'GET', body: any = null, headers: HeadersInit | undefined = {}) => {\n        setLoading(true)\n        try {\n            const response = await fetch(url, {method, body, headers})\n            const data = await response.json()\n\n            if(!response.ok) {\n                throw new Error('Something went wrong')\n            }\n\n            setLoading(false)\n\n            return data\n        } catch (e) {\n            setLoading(false)\n            setError(e)\n            throw e\n        }\n    }, [])  \n\n    return { loading, request, error }\n}"]},"metadata":{},"sourceType":"module"}